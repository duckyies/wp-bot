<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 4.0.2">
  <meta charset="utf-8">
  <title>wp-bot 4.3.2 &raquo; Source: src/commands/games/wordle.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">wp-bot 4.<wbr>3.<wbr>2</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: src/commands/games/wordle.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>import pkg from &#x27;whatsapp-web.js&#x27;;
import Jimp from &#x27;jimp&#x27;;
import words from &#x27;../utils/wordlewords.js&#x27;;
import baseuser from &#x27;../../models/baseuser.js&#x27;;
const { Client, LocalAuth, MessageMedia } &#x3D; pkg;
let listofwords &#x3D; words.split(&#x27;\n&#x27;);
listofwords &#x3D; listofwords.map(word &#x3D;&gt; word.trim().toLowerCase());
function randomWord() {
    return listofwords[Math.floor(Math.random() * listofwords.length)];
}
class wordle {
    constructor(client, id) {
        this.chatid &#x3D; id;
        this.client &#x3D; client;
        this.word &#x3D; randomWord();
        this.colors &#x3D; [[], [], [], [], [], []];
        this.letters &#x3D; [[], [], [], [], [], []];
        this.res &#x3D; &#x27;&#x27;;
        this.guesses &#x3D; 0;
    }
    chatid;
    client;
    word;
    colors;
    letters;
    res;
    guesses;
    async guess(guessedword) {
        this.guesses++;
        const { word } &#x3D; this;
        let res &#x3D; &#x27;&#x27;;
        for (let i &#x3D; 0; i &amp;lt; word.length; i++) {
            if (word[i] &#x3D;&#x3D; guessedword[i]) {
                this.res +&#x3D; &#x27;ðŸŸ©&#x27;;
                word.replace(guessedword[i], &#x27;$&#x27;);
                this.colors[this.guesses - 1].push(&#x27;0x538D4EFF&#x27;);
                this.letters[this.guesses - 1].push(guessedword[i]);
            }
            else if (word.includes(guessedword[i])) {
                word.replace(guessedword[i], &#x27;$&#x27;);
                this.colors[this.guesses - 1].push(&#x27;0xB59F3BFF&#x27;); // green 0x538D4EFF yel 0xB59F3BFF
                this.letters[this.guesses - 1].push(guessedword[i]);
                res +&#x3D; this.res +&#x3D; &#x27;ðŸŸ¨&#x27;;
            }
            else {
                this.colors[this.guesses - 1].push(&#x27;0x3a3a3cFF&#x27;);
                this.letters[this.guesses - 1].push(guessedword[i]);
                this.res +&#x3D; &#x27;â¬›&#x27;;
            }
        }
        this.res +&#x3D; &#x27;\n&#x27;;
    }
    async genimage() {
        const game &#x3D; this;
        const gridSize &#x3D; 5;
        const gridRows &#x3D; 6;
        const gridWidth &#x3D; 100;
        const gridHeight &#x3D; 100;
        const borderWidth &#x3D; 2;
        const separation &#x3D; 5;
        const imageWidth &#x3D; gridSize * gridWidth + (gridSize - 1) * separation;
        const imageHeight &#x3D; gridRows * gridHeight + (gridRows - 1) * separation;
        const image &#x3D; new Jimp(imageWidth, imageHeight, 0x121213ff);
        async function drawGridCell(x, y, bgColor, letter &#x3D; null) {
            image.scan(x, y, gridWidth, gridHeight, function (x, y, idx) {
                this.bitmap.data[idx + 0] &#x3D; (bgColor &gt;&gt; 24) &amp;amp; 0xff;
                this.bitmap.data[idx + 1] &#x3D; (bgColor &gt;&gt; 16) &amp;amp; 0xff;
                this.bitmap.data[idx + 2] &#x3D; (bgColor &gt;&gt; 8) &amp;amp; 0xff;
                this.bitmap.data[idx + 3] &#x3D; bgColor &amp;amp; 0xff;
            });
            for (let i &#x3D; 0; i &amp;lt; borderWidth; i++) {
                for (let j &#x3D; 0; j &amp;lt; gridWidth; j++) {
                    image.setPixelColor(0x3a3a3cff, x + j, y + i);
                    image.setPixelColor(0x3a3a3cff, x + j, y + gridHeight - 1 - i);
                }
                for (let j &#x3D; 0; j &amp;lt; gridHeight; j++) {
                    image.setPixelColor(0x3a3a3cff, x + i, y + j);
                    image.setPixelColor(0x3a3a3cff, x + gridWidth - 1 - i, y + j);
                }
            }
            if (letter) {
                letter &#x3D; letter.toUpperCase();
                const font &#x3D; await Jimp.loadFont(Jimp.FONT_SANS_64_WHITE);
                const textWidth &#x3D; Jimp.measureText(font, letter);
                // @ts-ignore
                const textHeight &#x3D; Jimp.measureTextHeight(font, letter);
                const textX &#x3D; x + (gridWidth - textWidth) / 2;
                const textY &#x3D; y + 37 + (gridHeight - textHeight) / 2;
                await image.print(font, textX, textY, letter);
            }
        }
        async function drawGrid() {
            for (let i &#x3D; 0; i &amp;lt; gridRows; i++) {
                for (let j &#x3D; 0; j &amp;lt; gridSize; j++) {
                    const x &#x3D; j * gridWidth + j * separation;
                    const y &#x3D; i * gridHeight + i * separation;
                    const color &#x3D; game.colors[i][j] || 0x121213ff;
                    const letter &#x3D; game.letters[i][j] || null;
                    await drawGridCell(x, y, color, letter);
                }
            }
        }
        await drawGrid();
        const b64 &#x3D; await image.getBase64Async(&#x27;image/png&#x27;);
        return b64.slice(22);
    }
}
export const name &#x3D; &#x27;wordle&#x27;;
export const args &#x3D; true;
export const aliases &#x3D; [&#x27;w&#x27;];
export const description &#x3D; &#x27;Play a game of wordle from NYT games&#x27;;
export const category &#x3D; &#x27;Games&#x27;;
/**
 * Implements the Wordle word game within WhatsApp, including image generation.
 *
 * **Usage (within the bot):**
 * - Call &#x60;genimage&#x60; to create an initial image of the game board.
 * - Use &#x60;guess&#x60; to process user guesses and update the game state.
 * - Call &#x60;genimage&#x60; again to generate an updated image after each guess.
 *
 * **User Commands:**
 * - &#x60;!wordle&#x60; or &#x60;!w&#x60; - Starts a new Wordle game.
 * - &#x60;guess {word}&#x60; - Submits a guess for the Wordle puzzle.
 * - &#x60;QUIT&#x60; - Ends the current game.
 */
export async function run(client, msg, args) {
    if (client.ingame) {
        msg.reply(&#x27;A game is currently active!&#x27;);
        return;
    }
    client.ingame &#x3D; true;
    const chat &#x3D; await msg.getChat();
    const game &#x3D; new wordle(client, chat.id._serialized);
    const b64 &#x3D; await game.genimage();
    const media2 &#x3D; new MessageMedia(&#x27;image/png&#x27;, b64);
    await msg.reply(media2);
    let done &#x3D; true;
    client.on(&#x27;message_create&#x27;, async function trial(msg) {
        const chatid &#x3D; await msg.getChat();
        if (chatid.id._serialized !&#x3D; game.chatid) {
            return;
        }
        if (!done) {
            return;
        }
        done &#x3D; false;
        if (msg.body.toLowerCase() &#x3D;&#x3D; &#x27;quit&#x27;) {
            client.removeListener(&#x27;message_create&#x27;, trial);
            client.ingame &#x3D; false;
            return msg.reply(&#x27;Game ended&#x27;);
        }
        if (msg.body.toLowerCase().startsWith(&#x27;guess &#x27;)) {
            let guessed &#x3D; msg.body.slice(6);
            guessed &#x3D; guessed.toLowerCase().trim();
            if (guessed.length !&#x3D; 5) {
                done &#x3D; true;
                return msg.reply(&#x27;Word must be 5 letters&#x27;);
            }
            if (!listofwords.includes(guessed)) {
                done &#x3D; true;
                return msg.reply(&#x27;That is not a word &#x27;);
            }
            const res &#x3D; await game.guess(guessed);
            const base &#x3D; await game.genimage();
            const media &#x3D; new MessageMedia(&#x27;image/png&#x27;, base);
            await msg.reply(media);
            done &#x3D; true;
            if (game.res.includes(&#x27;ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©&#x27;)) {
                client.removeListener(&#x27;message_create&#x27;, trial);
                client.ingame &#x3D; false;
                const contact &#x3D; await msg.getContact();
                const user &#x3D; new baseuser({
                    userId: contact.number,
                    users: client.cachedUsers,
                });
                user.addWordle();
                return msg.reply(&#x27;Your guess was correct!&#x27;);
            }
            if (game.guesses &#x3D;&#x3D; 6) {
                client.removeListener(&#x27;message_create&#x27;, trial);
                client.ingame &#x3D; false;
                return msg.reply(&#x60;lmao u lost. The word was ${game.word}&#x60;);
            }
        }
        done &#x3D; true;
    });
    // â¬›ðŸŸ©â¬›ðŸŸ¨â¬›
}
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 4.0.2 on April 27, 2024.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>