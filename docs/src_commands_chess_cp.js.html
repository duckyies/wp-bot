<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 4.0.2">
  <meta charset="utf-8">
  <title>wp-bot 4.3.2 &raquo; Source: src/commands/chess/cp.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">wp-bot 4.<wbr>3.<wbr>2</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: src/commands/chess/cp.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>import { parse } from &#x27;csv-parse&#x27;;
import { createReadStream } from &#x27;fs&#x27;;
import { Chess } from &#x27;chess.js&#x27;;
import pkg from &#x27;whatsapp-web.js&#x27;;
import baseuser from &#x27;../../models/baseuser.js&#x27;;
import client from &#x27;../../../index.js&#x27;;
const { Client, LocalAuth, MessageMedia } &#x3D; pkg;
// compare fen using san moves that u have with given move
// check for illegal move by playing the move, if played and no error but no match, wrong move, else if error then invalid move else correct
// PuzzleId,FEN,Moves,Rating,RatingDeviation,Popularity,NbPlays,Themes,GameUrl,OpeningTags
class puzzle {
    constructor(client, id, mode &#x3D; &#x27;onemove&#x27;) {
        this.mode &#x3D; mode;
        this.chatid &#x3D; id;
        this.client &#x3D; client;
        this.points &#x3D; 10;
        this.rating &#x3D; 0;
        this.themes &#x3D; &#x27;&#x27;;
        this.hintsused &#x3D; 0;
        this.moves &#x3D; [];
        this.wrongs &#x3D; 0;
        this.time &#x3D; 0;
        this.fen &#x3D; &#x27;&#x27;;
        this.newfen &#x3D; &#x27;&#x27;;
        this.gamelink &#x3D; &#x27;&#x27;;
        this.newmedia;
        this.newthemes &#x3D; &#x27;&#x27;;
        this.chess;
        this.newmoves &#x3D; [];
        this.newrating &#x3D; 0;
        this.newpoints &#x3D; 0;
        this.newgamelink &#x3D; &#x27;&#x27;;
        this.preloaded &#x3D; false;
    }
    client;
    id;
    chatid;
    mode;
    points;
    rating;
    themes;
    hintsused;
    moves;
    wrongs;
    time;
    chess;
    fen;
    newfen;
    gamelink;
    newmedia;
    newthemes;
    newmoves;
    newrating;
    newpoints;
    newgamelink;
    preloaded;
    async preloadpuzzle() {
        const game &#x3D; this;
        const random &#x3D; Math.floor(Math.random() * 3678110) + 1;
        createReadStream(&#x27;./src/commands/chess/lichess_db_puzzle.csv&#x27;)
            .pipe(parse({ delimiter: &#x27;,&#x27;, from_line: random, to_line: random }))
            .on(&#x27;data&#x27;, async function (row) {
            game.newthemes &#x3D; row[7];
            if (game.mode &#x3D;&#x3D; &#x27;onemove&#x27;) {
                game.newmoves &#x3D; [row[2].split(&#x27; &#x27;)[1]];
            }
            else {
                game.newmoves &#x3D; row[2].split(&#x27; &#x27;);
                game.newmoves.shift();
            }
            game.newrating &#x3D; row[3];
            game.newpoints &#x3D; Math.floor(game.newrating / 100);
            if (game.mode &#x3D;&#x3D; &#x27;onemove&#x27;) {
                game.newpoints &#x3D; Math.floor(game.newpoints / 2);
            }
            game.newgamelink &#x3D; row[8];
            const chess2 &#x3D; new Chess(row[1]);
            chess2.move(row[2].slice(0, 4));
            const newFen &#x3D; chess2.fen();
            game.newfen &#x3D; newFen;
            const media &#x3D; await game.getURL(newFen);
            game.newmedia &#x3D; media;
            game.preloaded &#x3D; true;
        });
    }
    async preloadmove() {
        // if mode is not &#x27;onemove&#x27;, preload the next move instead of a new puzzle.
        // skip opponents turn and continue puzzle
    }
    async getpuzzle() {
        if (!this.preloaded) {
            setTimeout(async () &#x3D;&gt; this.getpuzzle(), 2000);
            return;
        }
        this.preloaded &#x3D; false;
        await this.client.sendMessage(this.chatid, this.newmedia);
        const chess &#x3D; new Chess(this.newfen);
        this.chess &#x3D; chess;
        this.rating &#x3D; this.newrating;
        this.points &#x3D; this.newpoints;
        this.themes &#x3D; this.newthemes;
        this.gamelink &#x3D; this.newgamelink;
        this.moves &#x3D; this.newmoves;
        this.fen &#x3D; this.newfen;
        this.hintsused &#x3D; 0;
        this.wrongs &#x3D; 0;
        this.time &#x3D; Date.now();
        this.waitforanswer();
        this.preloadpuzzle();
    }
    async getURL(fen) {
        const color &#x3D; fen.split(&#x27; &#x27;)[1];
        const url &#x3D; &#x60;https://fen2image.chessvision.ai/${fen}?turn&#x3D;${color &#x3D;&#x3D; &#x27;w&#x27; ? &#x27;white&#x27; : &#x27;black&#x27;}&amp;amp;pov&#x3D;${color &#x3D;&#x3D; &#x27;w&#x27; ? &#x27;white&#x27; : &#x27;black&#x27;}&#x60;;
        const media &#x3D; await MessageMedia.fromUrl(url, { unsafeMime: true });
        return media;
    }
    async waitforanswer() {
        const nextmove &#x3D; this.moves[0];
        const game &#x3D; this;
        await this.chess.move(nextmove);
        const newfen &#x3D; this.chess.fen();
        await this.chess.undo();
        this.client.on(&#x27;message_create&#x27;, async function wait(msg) {
            const chat &#x3D; await msg.getChat();
            if (chat.id._serialized !&#x3D; game.chatid) {
                return;
            }
            const user &#x3D; await msg.getContact();
            let res &#x3D; msg.body;
            if (res.toLowerCase() &#x3D;&#x3D; &#x27;link&#x27; ||
                res.toLowerCase() &#x3D;&#x3D; &#x27;quit&#x27; ||
                res.toLowerCase() &#x3D;&#x3D; &#x27;solution&#x27;) {
                game.points &#x3D; 0;
                game.points -&#x3D; 5;
                for (let i &#x3D; 0; i &amp;lt; game.moves.length; i++) {
                    game.chess.move(game.moves[i]);
                }
                game.client.sendMessage(game.chatid, &#x60;Solution - ${game.chess.history().join(&#x27; &#x27;)}&#x60;);
                game.client.sendMessage(game.chatid, &#x60;Lichess puzzle link - ${game.gamelink}&#x60;);
                game.client.sendMessage(game.chatid, &#x27;Game ended!&#x27;);
                game.client.ingame &#x3D; false;
                game.client.removeListener(&#x27;message_create&#x27;, wait);
                return;
            }
            if (res.toLowerCase() &#x3D;&#x3D; &#x27;hint&#x27;) {
                if (game.hintsused &#x3D;&#x3D; 0) {
                    game.points -&#x3D; 3;
                    game.client.sendMessage(game.chatid, &#x60;Square to move from - ${nextmove.slice(0, 2)}&#x60;);
                    game.hintsused++;
                }
                else if (game.hintsused &#x3D;&#x3D; 1) {
                    game.points -&#x3D; 5;
                    game.client.sendMessage(game.chatid, &#x60;Square to move to - ${nextmove.slice(2, 4)}&#x60;);
                    game.hintsused++;
                }
                else if (game.hintsused &#x3D;&#x3D; 2) {
                    game.points -&#x3D; 5;
                    game.client.sendMessage(game.chatid, &#x60;Puzzle tags -  ${game.themes}&#x60;);
                    game.hintsused++;
                }
                else {
                    game.client.sendMessage(game.chatid, &#x27;All hints used up!&#x27;);
                }
            }
            else if (res.toLowerCase().startsWith(&#x27;move &#x27;) ||
                res.toLowerCase().startsWith(&#x27;play &#x27;)) {
                res &#x3D; res.slice(5);
                try {
                    game.chess.move(res);
                    if (game.chess.fen() &#x3D;&#x3D; newfen) {
                        msg.react(&#x27;✅&#x27;);
                        game.moves.shift();
                        if (game.moves.length &#x3D;&#x3D; 0) {
                            const timetaken &#x3D; (Date.now() - game.time) / 1000;
                            game.client.sendMessage(game.chatid, &#x60;Your solution was correct! You solved it in *${timetaken}* seconds! \nYou used *${game.hintsused}* hints. \nYou got *${game.points}* points!&#x60;);
                            game.client.sendMessage(game.chatid, &#x60;Lichess puzzle link - ${game.gamelink}&#x60;);
                            const user2 &#x3D; new baseuser({
                                userId: user.number,
                                users: game.client.cachedUsers,
                            });
                            user2.setPuzzleELO(game.points);
                            game.client.ingame &#x3D; false;
                            game.client.removeListener(&#x27;message_create&#x27;, wait);
                        }
                        else {
                            const media &#x3D; await game.getURL(game.chess.fen());
                            game.client.sendMessage(game.chatid, media);
                            game.waitforanswer();
                        }
                    }
                    else {
                        msg.react(&#x27;❌&#x27;);
                        game.points -&#x3D; 2;
                        game.wrongs++;
                        game.chess.undo();
                    }
                }
                catch (e) {
                    console.log(e);
                    msg.react(&#x27;⁉&#x27;);
                }
            }
        });
    }
}
const game &#x3D; new puzzle(client, &#x27;&#x27;, &#x27;onemove&#x27;);
game.preloadpuzzle();
export const name &#x3D; &#x27;Chess Puzzle&#x27;;
export const args &#x3D; true;
export const aliases &#x3D; [&#x27;chess&#x27;, &#x27;puzzle&#x27;, &#x27;cp&#x27;];
export const description &#x3D; &#x27;Get one move chess puzzles&#x27;;
export const category &#x3D; &#x27;Chess&#x27;;
/**
 * Manages chess puzzles within a WhatsApp chat.
 *
 * This class handles puzzle loading, retrieval, user interaction, and scoring.
 * It utilizes the &#x27;chess.js&#x27; library for game logic and interacts with a CSV database of puzzles.
 *
 * **Usage (within the bot):**
 * - Instantiate a &#x60;puzzle&#x60; object with the client and chat ID.
 * - Call &#x60;preloadpuzzle&#x60; to prepare a puzzle in advance.
 * - Call &#x60;getpuzzle&#x60; to send a puzzle to the chat and start the solving process.
 * - The class automatically handles user responses and game flow.
 *
 * **User Commands:**
 * - &#x60;!chess&#x60; or &#x60;!cp&#x60; - Starts a one-move chess puzzle.
 * - &#x60;!chess full&#x60; - Starts a multi-move chess puzzle.
 * - &#x60;hint&#x60; - Provides a hint (with point deduction).
 * - &#x60;move {move}&#x60; - Submits a move (e.g., &#x60;move e4&#x60;).
 * - &#x60;link&#x60; or &#x60;solution&#x60; - Ends the game and reveals the solution.
 */
export async function run(client, msg, args) {
    if (client.ingame) {
        msg.reply(&#x27;A game is currently active!&#x27;);
        return;
    }
    client.ingame &#x3D; true;
    const chat &#x3D; await msg.getChat();
    let mode &#x3D; &#x27;onemove&#x27;;
    if (args.join(&#x27; &#x27;).toLowerCase() &#x3D;&#x3D; &#x27;f&#x27; ||
        args.join(&#x27; &#x27;).toLowerCase() &#x3D;&#x3D; &#x27;full&#x27;) {
        mode &#x3D; &#x27;full&#x27;;
    }
    game.client &#x3D; client;
    game.chatid &#x3D; chat.id._serialized;
    game.mode &#x3D; mode;
    game.getpuzzle();
}
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 4.0.2 on April 28, 2024.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>